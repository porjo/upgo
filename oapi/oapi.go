// Package oapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package oapi

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
)

const (
	Bearer_authScopes = "bearer_auth.Scopes"
)

// AccountResource Provides information about an Up bank account.
type AccountResource struct {
	Attributes struct {
		// AccountType The bank account type of this account.
		AccountType AccountTypeEnum `json:"accountType"`

		// Balance The available balance of the account, taking into account any amounts
		// that are currently on hold.
		Balance MoneyObject `json:"balance"`

		// CreatedAt The date-time at which this account was first opened.
		CreatedAt time.Time `json:"createdAt"`

		// DisplayName The name associated with the account in the Up application.
		DisplayName string `json:"displayName"`

		// OwnershipType The ownership structure for this account.
		OwnershipType OwnershipTypeEnum `json:"ownershipType"`
	} `json:"attributes"`

	// Id The unique identifier for this account.
	Id    string `json:"id"`
	Links struct {
		// Self The canonical link to this resource within the API.
		Self string `json:"self"`
	} `json:"links,omitempty,omitzero"`
	Relationships struct {
		Transactions struct {
			Links struct {
				// Related The link to retrieve the related resource(s) in this relationship.
				Related string `json:"related"`
			} `json:"links,omitempty,omitzero"`
		} `json:"transactions"`
	} `json:"relationships"`

	// Type The type of this resource: `accounts`
	Type string `json:"type"`
}

// AccountTypeEnum Specifies the type of bank account. Currently returned values are
// `SAVER`, `TRANSACTIONAL` and `HOME_LOAN`.
type AccountTypeEnum = interface{}

// AttachmentResource defines model for AttachmentResource.
type AttachmentResource struct {
	Attributes struct {
		// CreatedAt The date-time when the file was created.
		CreatedAt time.Time `json:"createdAt"`

		// FileContentType Content type for the uploaded attachment.
		FileContentType string `json:"fileContentType"`

		// FileExtension File extension for the uploaded attachment.
		FileExtension string `json:"fileExtension"`

		// FileURL A temporary link to download the file.
		FileURL string `json:"fileURL"`

		// FileURLExpiresAt The date-time at which the `fileURL` link expires.
		FileURLExpiresAt time.Time `json:"fileURLExpiresAt"`
	} `json:"attributes"`

	// Id The unique identifier for this attachment.
	Id    string `json:"id"`
	Links struct {
		// Self The canonical link to this resource within the API.
		Self string `json:"self"`
	} `json:"links,omitempty,omitzero"`
	Relationships struct {
		Transaction struct {
			Data struct {
				// Id The unique identifier of the resource within its type.
				Id string `json:"id"`

				// Type The type of this resource: `transactions`
				Type string `json:"type"`
			} `json:"data"`
			Links struct {
				// Related The link to retrieve the related resource(s) in this relationship.
				Related string `json:"related"`
			} `json:"links,omitempty,omitzero"`
		} `json:"transaction"`
	} `json:"relationships"`

	// Type The type of this resource: `attachments`
	Type string `json:"type"`
}

// CardPurchaseMethodEnum Specifies the type of card charge.
type CardPurchaseMethodEnum = interface{}

// CardPurchaseMethodObject Provides information about the card used for a transaction.
type CardPurchaseMethodObject struct {
	// CardNumberSuffix The last four digits of the card used for the purchase, if applicable.
	CardNumberSuffix string `json:"cardNumberSuffix"`

	// Method The type of card purchase.
	Method CardPurchaseMethodEnum `json:"method"`
}

// CashbackObject Provides information about an instant reimbursement in the form of
// cashback.
type CashbackObject struct {
	// Amount The total amount of cashback paid, represented as a positive value.
	Amount MoneyObject `json:"amount"`

	// Description A brief description of why this cashback was paid.
	Description string `json:"description"`
}

// CategoryInputResourceIdentifier Uniquely identifies a category in the API.
type CategoryInputResourceIdentifier struct {
	// Id The unique identifier of the category, as returned by the `/categories`
	// endpoint.
	Id string `json:"id"`

	// Type The type of this resource: `categories`
	Type string `json:"type"`
}

// CategoryResource Provides information about a category and its ancestry.
type CategoryResource struct {
	Attributes struct {
		// Name The name of this category as seen in the Up application.
		Name string `json:"name"`
	} `json:"attributes"`

	// Id The unique identifier for this category. This is a human-readable but
	// URL-safe value.
	Id    string `json:"id"`
	Links struct {
		// Self The canonical link to this resource within the API.
		Self string `json:"self"`
	} `json:"links,omitempty,omitzero"`
	Relationships struct {
		Children struct {
			Data []struct {
				// Id The unique identifier of the resource within its type.
				Id string `json:"id"`

				// Type The type of this resource: `categories`
				Type string `json:"type"`
			} `json:"data"`
			Links struct {
				// Related The link to retrieve the related resource(s) in this relationship.
				Related string `json:"related"`
			} `json:"links,omitempty,omitzero"`
		} `json:"children"`
		Parent struct {
			Data struct {
				// Id The unique identifier of the resource within its type.
				Id string `json:"id"`

				// Type The type of this resource: `categories`
				Type string `json:"type"`
			} `json:"data"`
			Links struct {
				// Related The link to retrieve the related resource(s) in this relationship.
				Related string `json:"related"`
			} `json:"links,omitempty,omitzero"`
		} `json:"parent"`
	} `json:"relationships"`

	// Type The type of this resource: `categories`
	Type string `json:"type"`
}

// CreateWebhookRequest Request to create a new webhook. This currently only requires a `url`
// attribute.
type CreateWebhookRequest struct {
	// Data The webhook resource to create.
	Data WebhookInputResource `json:"data"`
}

// CreateWebhookResponse Successful response after creating a webhook.
type CreateWebhookResponse struct {
	// Data The webhook that was created.
	Data WebhookResource `json:"data"`
}

// CustomerObject Provides information about the customer who initiated a transaction
type CustomerObject struct {
	// DisplayName The Upname or preferred name of the customer
	DisplayName string `json:"displayName"`
}

// ErrorObject Provides information about an error processing a request.
type ErrorObject struct {
	// Detail A detailed description of this error. This should be considered unique
	// to individual occurrences of an error and subject to change. It is
	// useful for debugging purposes.
	Detail string `json:"detail"`

	// Source If applicable, location in the request that this error relates to. This
	// may be a parameter in the query string, or a an attribute in the
	// request body.
	Source struct {
		// Parameter If this error relates to a query parameter, the name of the
		// parameter.
		Parameter string `json:"parameter,omitempty,omitzero"`

		// Pointer If this error relates to an attribute in the request body, a
		// rfc-6901 JSON pointer to the attribute.
		Pointer string `json:"pointer,omitempty,omitzero"`
	} `json:"source,omitempty,omitzero"`

	// Status The HTTP status code associated with this error. This can also be
	// obtained from the response headers. The status indicates the broad type
	// of error according to HTTP semantics.
	Status string `json:"status"`

	// Title A short description of this error. This should be stable across
	// multiple occurrences of this type of error and typically expands on the
	// reason for the status code.
	Title string `json:"title"`
}

// ErrorResponse Generic error response that returns one or more errors.
type ErrorResponse struct {
	// Errors The list of errors returned in this response.
	Errors []ErrorObject `json:"errors"`
}

// GetAccountResponse Successful response to get a single account.
type GetAccountResponse struct {
	// Data The account returned in this response.
	Data AccountResource `json:"data"`
}

// GetAttachmentResponse Successful response to get a single attachment.
type GetAttachmentResponse struct {
	// Data The attachment returned in this response.
	Data AttachmentResource `json:"data"`
}

// GetCategoryResponse Successful response to get a single category and its ancestry.
type GetCategoryResponse struct {
	// Data The category returned in this response.
	Data CategoryResource `json:"data"`
}

// GetTransactionResponse Successful response to get a single transaction.
type GetTransactionResponse struct {
	// Data The transaction returned in this response.
	Data TransactionResource `json:"data"`
}

// GetWebhookResponse Successful response to get a single webhook.
type GetWebhookResponse struct {
	// Data The webhook returned in this response.
	Data WebhookResource `json:"data"`
}

// HoldInfoObject Provides information about the amount at which a transaction was in the
// `HELD` status.
type HoldInfoObject struct {
	// Amount The amount of this transaction while in the `HELD` status, in
	// Australian dollars.
	Amount MoneyObject `json:"amount"`

	// ForeignAmount The foreign currency amount of this transaction while in the `HELD`
	// status. This field will be `null` for domestic transactions. The amount
	// was converted to the AUD amount reflected in the `amount` field.
	ForeignAmount MoneyObject `json:"foreignAmount"`
}

// ListAccountsResponse Successful response to get all accounts. This returns a paginated list of
// accounts, which can be scrolled by following the `prev` and `next` links
// if present.
type ListAccountsResponse struct {
	// Data The list of accounts returned in this response.
	Data  []AccountResource `json:"data"`
	Links struct {
		// Next The link to the next page in the results. If this value is `null`
		// there is no next page.
		Next string `json:"next"`

		// Prev The link to the previous page in the results. If this value is `null`
		// there is no previous page.
		Prev string `json:"prev"`
	} `json:"links"`
}

// ListAttachmentsResponse Successful response to get all attachments. This returns a paginated list of
// attachments, which can be scrolled by following the `prev` and `next` links if
// present.
type ListAttachmentsResponse struct {
	// Data The list of attachments returned in this response.
	Data  []AttachmentResource `json:"data"`
	Links struct {
		// Next The link to the next page in the results. If this value is `null`
		// there is no next page.
		Next string `json:"next"`

		// Prev The link to the previous page in the results. If this value is `null`
		// there is no previous page.
		Prev string `json:"prev"`
	} `json:"links"`
}

// ListCategoriesResponse Successful response to get all categories and their ancestry. The
// returned list is not paginated.
type ListCategoriesResponse struct {
	// Data The list of categories returned in this response.
	Data []CategoryResource `json:"data"`
}

// ListTagsResponse Successful response to get all tags. This returns a paginated list of
// tags, which can be scrolled by following the `prev` and `next` links if
// present.
type ListTagsResponse struct {
	// Data The list of tags returned in this response.
	Data  []TagResource `json:"data"`
	Links struct {
		// Next The link to the next page in the results. If this value is `null`
		// there is no next page.
		Next string `json:"next"`

		// Prev The link to the previous page in the results. If this value is `null`
		// there is no previous page.
		Prev string `json:"prev"`
	} `json:"links"`
}

// ListTransactionsResponse Successful response to get all transactions. This returns a paginated
// list of transactions, which can be scrolled by following the `prev` and
// `next` links if present.
type ListTransactionsResponse struct {
	// Data The list of transactions returned in this response.
	Data  []TransactionResource `json:"data"`
	Links struct {
		// Next The link to the next page in the results. If this value is `null`
		// there is no next page.
		Next string `json:"next"`

		// Prev The link to the previous page in the results. If this value is `null`
		// there is no previous page.
		Prev string `json:"prev"`
	} `json:"links"`
}

// ListWebhookDeliveryLogsResponse Successful response to get all delivery logs for a webhook. This returns
// a paginated list of delivery logs, which can be scrolled by following the
// `next` and `prev` links if present.
type ListWebhookDeliveryLogsResponse struct {
	// Data The list of delivery logs returned in this response.
	Data  []WebhookDeliveryLogResource `json:"data"`
	Links struct {
		// Next The link to the next page in the results. If this value is `null`
		// there is no next page.
		Next string `json:"next"`

		// Prev The link to the previous page in the results. If this value is `null`
		// there is no previous page.
		Prev string `json:"prev"`
	} `json:"links"`
}

// ListWebhooksResponse Successful response to get all webhooks. This returns a paginated list of
// webhooks, which can be scrolled by following the `prev` and `next` links
// if present.
type ListWebhooksResponse struct {
	// Data The list of webhooks returned in this response.
	Data  []WebhookResource `json:"data"`
	Links struct {
		// Next The link to the next page in the results. If this value is `null`
		// there is no next page.
		Next string `json:"next"`

		// Prev The link to the previous page in the results. If this value is `null`
		// there is no previous page.
		Prev string `json:"prev"`
	} `json:"links"`
}

// MoneyObject Provides information about a value of money.
type MoneyObject struct {
	// CurrencyCode The ISO 4217 currency code.
	CurrencyCode string `json:"currencyCode"`

	// Value The amount of money, formatted as a string in the relevant currency.
	// For example, for an Australian dollar value of $10.56, this field will
	// be `"10.56"`. The currency symbol is not included in the string.
	Value string `json:"value"`

	// ValueInBaseUnits The amount of money in the smallest denomination for the currency, as a
	// 64-bit integer.  For example, for an Australian dollar value of $10.56,
	// this field will be `1056`.
	ValueInBaseUnits int `json:"valueInBaseUnits"`
}

// NoteObject Provides information about the note and attachement.
type NoteObject struct {
	// Text A text note about the transaction.
	Text string `json:"text"`
}

// OwnershipTypeEnum Specifies the structure under which a bank account is owned. Currently
// returned values are `INDIVIDUAL` and `JOINT`.
type OwnershipTypeEnum = interface{}

// PingResponse Basic ping response to verify authentication.
type PingResponse struct {
	Meta struct {
		// Id The unique identifier of the authenticated customer.
		Id string `json:"id"`

		// StatusEmoji A cute emoji that represents the response status.
		StatusEmoji string `json:"statusEmoji"`
	} `json:"meta"`
}

// RoundUpObject Provides information about how a Round Up was applied, such as whether or
// not a boost was included in the Round Up.
type RoundUpObject struct {
	// Amount The total amount of this Round Up, including any boosts, represented as
	// a negative value.
	Amount MoneyObject `json:"amount"`

	// BoostPortion The portion of the Round Up `amount` owing to boosted Round Ups,
	// represented as a negative value. If no boost was added to the Round Up
	// this field will be `null`.
	BoostPortion MoneyObject `json:"boostPortion"`
}

// TagInputResourceIdentifier Uniquely identifies a single tag in the API.
type TagInputResourceIdentifier struct {
	// Id The label of the tag, which also acts as the tag’s unique identifier.
	Id string `json:"id"`

	// Type The type of this resource: `tags`
	Type string `json:"type"`
}

// TagResource Provides information about a tag.
type TagResource struct {
	// Id The label of the tag, which also acts as the tag’s unique identifier.
	Id            string `json:"id"`
	Relationships struct {
		Transactions struct {
			Links struct {
				// Related The link to retrieve the related resource(s) in this relationship.
				Related string `json:"related"`
			} `json:"links,omitempty,omitzero"`
		} `json:"transactions"`
	} `json:"relationships"`

	// Type The type of this resource: `tags`
	Type string `json:"type"`
}

// TransactionResource defines model for TransactionResource.
type TransactionResource struct {
	Attributes struct {
		// Amount The amount of this transaction in Australian dollars. For
		// transactions that were once `HELD` but are now `SETTLED`, refer to
		// the `holdInfo` field for the original `amount` the transaction was
		// `HELD` at.
		Amount MoneyObject `json:"amount"`

		// CardPurchaseMethod Information about the card used for this transaction, if applicable.
		CardPurchaseMethod CardPurchaseMethodObject `json:"cardPurchaseMethod"`

		// Cashback If all or part of this transaction was instantly reimbursed in the
		// form of cashback, details of the reimbursement.
		Cashback CashbackObject `json:"cashback"`

		// CreatedAt The date-time at which this transaction was first encountered.
		CreatedAt time.Time `json:"createdAt"`

		// Description A short description for this transaction. Usually the merchant name
		// for purchases.
		Description string `json:"description"`

		// ForeignAmount The foreign currency amount of this transaction. This field will be
		// `null` for domestic transactions. The amount was converted to the AUD
		// amount reflected in the `amount` of this transaction. Refer to the
		// `holdInfo` field for the original `foreignAmount` the transaction was
		// `HELD` at.
		ForeignAmount MoneyObject `json:"foreignAmount"`

		// HoldInfo If this transaction is currently in the `HELD` status, or was ever in
		// the `HELD` status, the `amount` and `foreignAmount` of the
		// transaction while `HELD`.
		HoldInfo HoldInfoObject `json:"holdInfo"`

		// IsCategorizable Boolean flag set to true on transactions that support the use of
		// categories.
		IsCategorizable bool `json:"isCategorizable"`

		// Message Attached message for this transaction, such as a payment message, or a
		// transfer note.
		Message string `json:"message"`

		// Note A customer provided note about the transaction.  Can only be provided by Up High subscribers.
		Note NoteObject `json:"note"`

		// PerformingCustomer The customer who initated the transaction.  For 2Up accounts this could be the customer who's card was used.
		PerformingCustomer CustomerObject `json:"performingCustomer"`

		// RawText The original, unprocessed text of the transaction. This is often not
		// a perfect indicator of the actual merchant, but it is useful for
		// reconciliation purposes in some cases.
		RawText string `json:"rawText"`

		// RoundUp Details of how this transaction was rounded-up. If no Round Up was
		// applied this field will be `null`.
		RoundUp RoundUpObject `json:"roundUp"`

		// SettledAt The date-time at which this transaction settled. This field will be
		// `null` for transactions that are currently in the `HELD` status.
		SettledAt time.Time `json:"settledAt"`

		// Status The current processing status of this transaction, according to
		// whether or not this transaction has settled or is still held.
		Status TransactionStatusEnum `json:"status"`

		// TransactionType A description of the transaction method used e.g. Purchase, BPAY Payment.
		TransactionType string `json:"transactionType"`
	} `json:"attributes"`

	// Id The unique identifier for this transaction.
	Id    string `json:"id"`
	Links struct {
		// Self The canonical link to this resource within the API.
		Self string `json:"self"`
	} `json:"links,omitempty,omitzero"`
	Relationships struct {
		Account struct {
			Data struct {
				// Id The unique identifier of the resource within its type.
				Id string `json:"id"`

				// Type The type of this resource: `accounts`
				Type string `json:"type"`
			} `json:"data"`
			Links struct {
				// Related The link to retrieve the related resource(s) in this relationship.
				Related string `json:"related"`
			} `json:"links,omitempty,omitzero"`
		} `json:"account"`
		Attachment struct {
			Data struct {
				// Id The unique identifier of the resource within its type.
				Id string `json:"id"`

				// Type The type of this resource: `attachments`
				Type string `json:"type"`
			} `json:"data"`
			Links struct {
				// Related The link to retrieve the related resource(s) in this relationship.
				Related string `json:"related"`
			} `json:"links,omitempty,omitzero"`
		} `json:"attachment"`
		Category struct {
			Data struct {
				// Id The unique identifier of the resource within its type.
				Id string `json:"id"`

				// Type The type of this resource: `categories`
				Type string `json:"type"`
			} `json:"data"`
			Links struct {
				// Related The link to retrieve the related resource(s) in this relationship.
				Related string `json:"related,omitempty,omitzero"`

				// Self The link to retrieve or modify linkage between this resources and the
				// related resource(s) in this relationship.
				Self string `json:"self"`
			} `json:"links,omitempty,omitzero"`
		} `json:"category"`
		ParentCategory struct {
			Data struct {
				// Id The unique identifier of the resource within its type.
				Id string `json:"id"`

				// Type The type of this resource: `categories`
				Type string `json:"type"`
			} `json:"data"`
			Links struct {
				// Related The link to retrieve the related resource(s) in this relationship.
				Related string `json:"related"`
			} `json:"links,omitempty,omitzero"`
		} `json:"parentCategory"`
		Tags struct {
			Data []struct {
				// Id The label of the tag, which also acts as the tag’s unique identifier.
				Id string `json:"id"`

				// Type The type of this resource: `tags`
				Type string `json:"type"`
			} `json:"data"`
			Links struct {
				// Self The link to retrieve or modify linkage between this resources and the
				// related resource(s) in this relationship.
				Self string `json:"self"`
			} `json:"links,omitempty,omitzero"`
		} `json:"tags"`

		// TransferAccount If this transaction is a transfer between accounts, this relationship
		// will contain the account the transaction went to/came from. The
		// `amount` field can be used to determine the direction of the transfer.
		TransferAccount struct {
			Data struct {
				// Id The unique identifier of the resource within its type.
				Id string `json:"id"`

				// Type The type of this resource: `accounts`
				Type string `json:"type"`
			} `json:"data"`
			Links struct {
				// Related The link to retrieve the related resource(s) in this relationship.
				Related string `json:"related"`
			} `json:"links,omitempty,omitzero"`
		} `json:"transferAccount"`
	} `json:"relationships"`

	// Type The type of this resource: `transactions`
	Type string `json:"type"`
}

// TransactionStatusEnum Specifies which stage of processing a transaction is currently at.
// Currently returned values are `HELD` and `SETTLED`. When a transaction is
// held, its account’s `availableBalance` is affected. When a transaction is
// settled, its account’s `currentBalance` is affected.
type TransactionStatusEnum = interface{}

// UpdateTransactionCategoryRequest Request to update the category associated with a transaction.
type UpdateTransactionCategoryRequest struct {
	// Data The category to set on the transaction. Set this entire key to `null`
	// de-categorize a transaction.
	Data CategoryInputResourceIdentifier `json:"data"`
}

// UpdateTransactionTagsRequest Request to add or remove tags associated with a transaction.
type UpdateTransactionTagsRequest struct {
	// Data The tags to add to or remove from the transaction.
	Data []TagInputResourceIdentifier `json:"data"`
}

// WebhookDeliveryLogResource Provides historical webhook event delivery information for analysis and
// debugging purposes.
type WebhookDeliveryLogResource struct {
	Attributes struct {
		// CreatedAt The date-time at which this log entry was created.
		CreatedAt time.Time `json:"createdAt"`

		// DeliveryStatus The success or failure status of this delivery attempt.
		DeliveryStatus WebhookDeliveryStatusEnum `json:"deliveryStatus"`

		// Request Information about the request that was sent to the webhook URL.
		Request struct {
			// Body The payload that was sent in the request body.
			Body string `json:"body"`
		} `json:"request"`

		// Response Information about the response that was received from the webhook URL.
		Response struct {
			// Body The payload that was received in the response body.
			Body string `json:"body"`

			// StatusCode The HTTP status code received in the response.
			StatusCode int `json:"statusCode"`
		} `json:"response"`
	} `json:"attributes"`

	// Id The unique identifier for this log entry.
	Id            string `json:"id"`
	Relationships struct {
		WebhookEvent struct {
			Data struct {
				// Id The unique identifier of the resource within its type.
				Id string `json:"id"`

				// Type The type of this resource: `webhook-events`
				Type string `json:"type"`
			} `json:"data"`
		} `json:"webhookEvent"`
	} `json:"relationships"`

	// Type The type of this resource: `webhook-delivery-logs`
	Type string `json:"type"`
}

// WebhookDeliveryStatusEnum Specifies the nature of the success or failure of a webhook delivery
// attempt to the subscribed webhook URL. The currently returned values are
// described below:
//
//   - **`DELIVERED`**: The event was delivered to the webhook URL
//     successfully and a `200` response was received.
//   - **`UNDELIVERABLE`**: The webhook URL was not reachable, or timed out.
//   - **`BAD_RESPONSE_CODE`**: The event was delivered to the webhook URL
//     but a non-`200` response was received.
type WebhookDeliveryStatusEnum = interface{}

// WebhookEventCallback Asynchronous callback request used for webhook event delivery.
type WebhookEventCallback struct {
	// Data The webhook event data sent to the subscribed webhook.
	Data WebhookEventResource `json:"data"`
}

// WebhookEventResource Provides the event data used in asynchronous webhook event callbacks to
// subscribed endpoints. Webhooks events have defined `eventType`s and may
// optionally relate to other resources within the Up API.
type WebhookEventResource struct {
	Attributes struct {
		// CreatedAt The date-time at which this event was generated.
		CreatedAt time.Time `json:"createdAt"`

		// EventType The type of this event. This can be used to determine what action to
		// take in response to the event.
		EventType WebhookEventTypeEnum `json:"eventType"`
	} `json:"attributes"`

	// Id The unique identifier for this event. This will remain constant across
	// delivery retries.
	Id            string `json:"id"`
	Relationships struct {
		Transaction struct {
			Data struct {
				// Id The unique identifier of the resource within its type.
				Id string `json:"id"`

				// Type The type of this resource: `transactions`
				Type string `json:"type"`
			} `json:"data"`
			Links struct {
				// Related The link to retrieve the related resource(s) in this relationship.
				Related string `json:"related"`
			} `json:"links,omitempty,omitzero"`
		} `json:"transaction,omitempty,omitzero"`
		Webhook struct {
			Data struct {
				// Id The unique identifier of the resource within its type.
				Id string `json:"id"`

				// Type The type of this resource: `webhooks`
				Type string `json:"type"`
			} `json:"data"`
			Links struct {
				// Related The link to retrieve the related resource(s) in this relationship.
				Related string `json:"related"`
			} `json:"links,omitempty,omitzero"`
		} `json:"webhook"`
	} `json:"relationships"`

	// Type The type of this resource: `webhook-events`
	Type string `json:"type"`
}

// WebhookEventTypeEnum Specifies the type of a webhook event. This can be used to determine what
// action to take in response to the event, such as which relationships to
// expect.
type WebhookEventTypeEnum = interface{}

// WebhookInputResource Represents a webhook specified as request input.
type WebhookInputResource struct {
	Attributes struct {
		// Description An optional description for this webhook, up to 64 characters in
		// length.
		Description string `json:"description,omitzero"`

		// Url The URL that this webhook should post events to. This must be a valid
		// HTTP or HTTPS URL that does not exceed 300 characters in length.
		Url string `json:"url"`
	} `json:"attributes"`
}

// WebhookResource Provides information about a webhook.
type WebhookResource struct {
	Attributes struct {
		// CreatedAt The date-time at which this webhook was created.
		CreatedAt time.Time `json:"createdAt"`

		// Description An optional description that was provided at the time the webhook was
		// created.
		Description string `json:"description"`

		// SecretKey A shared secret key used to sign all webhook events sent to the
		// configured webhook URL. This field is returned only once, upon the
		// initial creation of the webhook. If lost, create a new webhook and
		// delete this webhook.
		//
		// The webhook URL receives a request with a
		// `X-Up-Authenticity-Signature` header, which is the SHA-256 HMAC of
		// the entire raw request body signed using this `secretKey`. It is
		// advised to compute and check this signature to verify the
		// authenticity of requests sent to the webhook URL. See
		// [Handling webhook events](#callback_post_webhookURL) for full
		// details.
		SecretKey string `json:"secretKey,omitempty,omitzero"`

		// Url The URL that this webhook is configured to `POST` events to.
		Url string `json:"url"`
	} `json:"attributes"`

	// Id The unique identifier for this webhook.
	Id    string `json:"id"`
	Links struct {
		// Self The canonical link to this resource within the API.
		Self string `json:"self"`
	} `json:"links,omitempty,omitzero"`
	Relationships struct {
		Logs struct {
			Links struct {
				// Related The link to retrieve the related resource(s) in this relationship.
				Related string `json:"related"`
			} `json:"links,omitempty,omitzero"`
		} `json:"logs"`
	} `json:"relationships"`

	// Type The type of this resource: `webhooks`
	Type string `json:"type"`
}

// GetAccountsParams defines parameters for GetAccounts.
type GetAccountsParams struct {
	// PageSize The number of records to return in each page.
	PageSize int `form:"page[size],omitempty" json:"page[size],omitempty,omitzero"`

	// FilterAccountType The type of account for which to return records. This
	// can be used to filter Savers from spending accounts.
	FilterAccountType AccountTypeEnum `form:"filter[accountType],omitempty" json:"filter[accountType],omitempty,omitzero"`

	// FilterOwnershipType The account ownership structure for which to return
	// records. This can be used to filter 2Up accounts from Up
	// accounts.
	FilterOwnershipType OwnershipTypeEnum `form:"filter[ownershipType],omitempty" json:"filter[ownershipType],omitempty,omitzero"`
}

// GetAccountsAccountIdTransactionsParams defines parameters for GetAccountsAccountIdTransactions.
type GetAccountsAccountIdTransactionsParams struct {
	// PageSize The number of records to return in each page.
	PageSize int `form:"page[size],omitempty" json:"page[size],omitempty,omitzero"`

	// FilterStatus The transaction status for which to return records. This
	// can be used to filter `HELD` transactions from those
	// that are `SETTLED`.
	FilterStatus TransactionStatusEnum `form:"filter[status],omitempty" json:"filter[status],omitempty,omitzero"`

	// FilterSince The start date-time from which to return records,
	// formatted according to rfc-3339. Not to be used for
	// pagination purposes.
	FilterSince time.Time `form:"filter[since],omitempty" json:"filter[since],omitempty,omitzero"`

	// FilterUntil The end date-time up to which to return records,
	// formatted according to rfc-3339. Not to be used for
	// pagination purposes.
	FilterUntil time.Time `form:"filter[until],omitempty" json:"filter[until],omitempty,omitzero"`

	// FilterCategory The category identifier for which to filter transactions.
	// Both parent and child categories can be filtered through
	// this parameter. Providing an invalid category identifier
	// results in a `404` response.
	FilterCategory string `form:"filter[category],omitempty" json:"filter[category],omitempty,omitzero"`

	// FilterTag A transaction tag to filter for which to return records.
	// If the tag does not exist, zero records are returned and
	// a success response is given.
	FilterTag string `form:"filter[tag],omitempty" json:"filter[tag],omitempty,omitzero"`
}

// GetCategoriesParams defines parameters for GetCategories.
type GetCategoriesParams struct {
	// FilterParent The unique identifier of a parent category for which to
	// return only its children. Providing an invalid category
	// identifier results in a `404` response.
	FilterParent string `form:"filter[parent],omitempty" json:"filter[parent],omitempty,omitzero"`
}

// GetTagsParams defines parameters for GetTags.
type GetTagsParams struct {
	// PageSize The number of records to return in each page.
	PageSize int `form:"page[size],omitempty" json:"page[size],omitempty,omitzero"`
}

// GetTransactionsParams defines parameters for GetTransactions.
type GetTransactionsParams struct {
	// PageSize The number of records to return in each page.
	PageSize int `form:"page[size],omitempty" json:"page[size],omitempty,omitzero"`

	// FilterStatus The transaction status for which to return records. This
	// can be used to filter `HELD` transactions from those
	// that are `SETTLED`.
	FilterStatus TransactionStatusEnum `form:"filter[status],omitempty" json:"filter[status],omitempty,omitzero"`

	// FilterSince The start date-time from which to return records,
	// formatted according to rfc-3339. Not to be used for
	// pagination purposes.
	FilterSince time.Time `form:"filter[since],omitempty" json:"filter[since],omitempty,omitzero"`

	// FilterUntil The end date-time up to which to return records,
	// formatted according to rfc-3339. Not to be used for
	// pagination purposes.
	FilterUntil time.Time `form:"filter[until],omitempty" json:"filter[until],omitempty,omitzero"`

	// FilterCategory The category identifier for which to filter transactions.
	// Both parent and child categories can be filtered through
	// this parameter. Providing an invalid category identifier
	// results in a `404` response.
	FilterCategory string `form:"filter[category],omitempty" json:"filter[category],omitempty,omitzero"`

	// FilterTag A transaction tag to filter for which to return records.
	// If the tag does not exist, zero records are returned and
	// a success response is given.
	FilterTag string `form:"filter[tag],omitempty" json:"filter[tag],omitempty,omitzero"`
}

// GetWebhooksParams defines parameters for GetWebhooks.
type GetWebhooksParams struct {
	// PageSize The number of records to return in each page.
	PageSize int `form:"page[size],omitempty" json:"page[size],omitempty,omitzero"`
}

// GetWebhooksWebhookIdLogsParams defines parameters for GetWebhooksWebhookIdLogs.
type GetWebhooksWebhookIdLogsParams struct {
	// PageSize The number of records to return in each page.
	PageSize int `form:"page[size],omitempty" json:"page[size],omitempty,omitzero"`
}

// PatchTransactionsTransactionIdRelationshipsCategoryJSONRequestBody defines body for PatchTransactionsTransactionIdRelationshipsCategory for application/json ContentType.
type PatchTransactionsTransactionIdRelationshipsCategoryJSONRequestBody = UpdateTransactionCategoryRequest

// DeleteTransactionsTransactionIdRelationshipsTagsJSONRequestBody defines body for DeleteTransactionsTransactionIdRelationshipsTags for application/json ContentType.
type DeleteTransactionsTransactionIdRelationshipsTagsJSONRequestBody = UpdateTransactionTagsRequest

// PostTransactionsTransactionIdRelationshipsTagsJSONRequestBody defines body for PostTransactionsTransactionIdRelationshipsTags for application/json ContentType.
type PostTransactionsTransactionIdRelationshipsTagsJSONRequestBody = UpdateTransactionTagsRequest

// PostWebhooksJSONRequestBody defines body for PostWebhooks for application/json ContentType.
type PostWebhooksJSONRequestBody = CreateWebhookRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAccounts request
	GetAccounts(ctx context.Context, params *GetAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAccountsAccountIdTransactions request
	GetAccountsAccountIdTransactions(ctx context.Context, accountId string, params *GetAccountsAccountIdTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAccountsId request
	GetAccountsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAttachments request
	GetAttachments(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAttachmentsId request
	GetAttachmentsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCategories request
	GetCategories(ctx context.Context, params *GetCategoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCategoriesId request
	GetCategoriesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTags request
	GetTags(ctx context.Context, params *GetTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTransactions request
	GetTransactions(ctx context.Context, params *GetTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTransactionsId request
	GetTransactionsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchTransactionsTransactionIdRelationshipsCategoryWithBody request with any body
	PatchTransactionsTransactionIdRelationshipsCategoryWithBody(ctx context.Context, transactionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchTransactionsTransactionIdRelationshipsCategory(ctx context.Context, transactionId string, body PatchTransactionsTransactionIdRelationshipsCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTransactionsTransactionIdRelationshipsTagsWithBody request with any body
	DeleteTransactionsTransactionIdRelationshipsTagsWithBody(ctx context.Context, transactionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteTransactionsTransactionIdRelationshipsTags(ctx context.Context, transactionId string, body DeleteTransactionsTransactionIdRelationshipsTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostTransactionsTransactionIdRelationshipsTagsWithBody request with any body
	PostTransactionsTransactionIdRelationshipsTagsWithBody(ctx context.Context, transactionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostTransactionsTransactionIdRelationshipsTags(ctx context.Context, transactionId string, body PostTransactionsTransactionIdRelationshipsTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUtilPing request
	GetUtilPing(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWebhooks request
	GetWebhooks(ctx context.Context, params *GetWebhooksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostWebhooksWithBody request with any body
	PostWebhooksWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostWebhooks(ctx context.Context, body PostWebhooksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWebhooksId request
	DeleteWebhooksId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWebhooksId request
	GetWebhooksId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWebhooksWebhookIdLogs request
	GetWebhooksWebhookIdLogs(ctx context.Context, webhookId string, params *GetWebhooksWebhookIdLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostWebhooksWebhookIdPing request
	PostWebhooksWebhookIdPing(ctx context.Context, webhookId string, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAccounts(ctx context.Context, params *GetAccountsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccountsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAccountsAccountIdTransactions(ctx context.Context, accountId string, params *GetAccountsAccountIdTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccountsAccountIdTransactionsRequest(c.Server, accountId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAccountsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAccountsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAttachments(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAttachmentsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAttachmentsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAttachmentsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCategories(ctx context.Context, params *GetCategoriesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCategoriesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCategoriesId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCategoriesIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTags(ctx context.Context, params *GetTagsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTagsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTransactions(ctx context.Context, params *GetTransactionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTransactionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTransactionsId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTransactionsIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchTransactionsTransactionIdRelationshipsCategoryWithBody(ctx context.Context, transactionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchTransactionsTransactionIdRelationshipsCategoryRequestWithBody(c.Server, transactionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchTransactionsTransactionIdRelationshipsCategory(ctx context.Context, transactionId string, body PatchTransactionsTransactionIdRelationshipsCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchTransactionsTransactionIdRelationshipsCategoryRequest(c.Server, transactionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTransactionsTransactionIdRelationshipsTagsWithBody(ctx context.Context, transactionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTransactionsTransactionIdRelationshipsTagsRequestWithBody(c.Server, transactionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTransactionsTransactionIdRelationshipsTags(ctx context.Context, transactionId string, body DeleteTransactionsTransactionIdRelationshipsTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTransactionsTransactionIdRelationshipsTagsRequest(c.Server, transactionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTransactionsTransactionIdRelationshipsTagsWithBody(ctx context.Context, transactionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTransactionsTransactionIdRelationshipsTagsRequestWithBody(c.Server, transactionId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTransactionsTransactionIdRelationshipsTags(ctx context.Context, transactionId string, body PostTransactionsTransactionIdRelationshipsTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTransactionsTransactionIdRelationshipsTagsRequest(c.Server, transactionId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUtilPing(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUtilPingRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWebhooks(ctx context.Context, params *GetWebhooksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWebhooksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostWebhooksWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostWebhooksRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostWebhooks(ctx context.Context, body PostWebhooksJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostWebhooksRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWebhooksId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWebhooksIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWebhooksId(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWebhooksIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWebhooksWebhookIdLogs(ctx context.Context, webhookId string, params *GetWebhooksWebhookIdLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWebhooksWebhookIdLogsRequest(c.Server, webhookId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostWebhooksWebhookIdPing(ctx context.Context, webhookId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostWebhooksWebhookIdPingRequest(c.Server, webhookId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAccountsRequest generates requests for GetAccounts
func NewGetAccountsRequest(server string, params *GetAccountsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page[size]", runtime.ParamLocationQuery, params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[accountType]", runtime.ParamLocationQuery, params.FilterAccountType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[ownershipType]", runtime.ParamLocationQuery, params.FilterOwnershipType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAccountsAccountIdTransactionsRequest generates requests for GetAccountsAccountIdTransactions
func NewGetAccountsAccountIdTransactionsRequest(server string, accountId string, params *GetAccountsAccountIdTransactionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "accountId", runtime.ParamLocationPath, accountId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts/%s/transactions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page[size]", runtime.ParamLocationQuery, params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[status]", runtime.ParamLocationQuery, params.FilterStatus); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[since]", runtime.ParamLocationQuery, params.FilterSince); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[until]", runtime.ParamLocationQuery, params.FilterUntil); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[category]", runtime.ParamLocationQuery, params.FilterCategory); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[tag]", runtime.ParamLocationQuery, params.FilterTag); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAccountsIdRequest generates requests for GetAccountsId
func NewGetAccountsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/accounts/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAttachmentsRequest generates requests for GetAttachments
func NewGetAttachmentsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attachments")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAttachmentsIdRequest generates requests for GetAttachmentsId
func NewGetAttachmentsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/attachments/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCategoriesRequest generates requests for GetCategories
func NewGetCategoriesRequest(server string, params *GetCategoriesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/categories")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[parent]", runtime.ParamLocationQuery, params.FilterParent); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCategoriesIdRequest generates requests for GetCategoriesId
func NewGetCategoriesIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/categories/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTagsRequest generates requests for GetTags
func NewGetTagsRequest(server string, params *GetTagsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tags")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page[size]", runtime.ParamLocationQuery, params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTransactionsRequest generates requests for GetTransactions
func NewGetTransactionsRequest(server string, params *GetTransactionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transactions")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page[size]", runtime.ParamLocationQuery, params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[status]", runtime.ParamLocationQuery, params.FilterStatus); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[since]", runtime.ParamLocationQuery, params.FilterSince); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[until]", runtime.ParamLocationQuery, params.FilterUntil); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[category]", runtime.ParamLocationQuery, params.FilterCategory); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "filter[tag]", runtime.ParamLocationQuery, params.FilterTag); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTransactionsIdRequest generates requests for GetTransactionsId
func NewGetTransactionsIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transactions/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPatchTransactionsTransactionIdRelationshipsCategoryRequest calls the generic PatchTransactionsTransactionIdRelationshipsCategory builder with application/json body
func NewPatchTransactionsTransactionIdRelationshipsCategoryRequest(server string, transactionId string, body PatchTransactionsTransactionIdRelationshipsCategoryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchTransactionsTransactionIdRelationshipsCategoryRequestWithBody(server, transactionId, "application/json", bodyReader)
}

// NewPatchTransactionsTransactionIdRelationshipsCategoryRequestWithBody generates requests for PatchTransactionsTransactionIdRelationshipsCategory with any type of body
func NewPatchTransactionsTransactionIdRelationshipsCategoryRequestWithBody(server string, transactionId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "transactionId", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transactions/%s/relationships/category", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTransactionsTransactionIdRelationshipsTagsRequest calls the generic DeleteTransactionsTransactionIdRelationshipsTags builder with application/json body
func NewDeleteTransactionsTransactionIdRelationshipsTagsRequest(server string, transactionId string, body DeleteTransactionsTransactionIdRelationshipsTagsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteTransactionsTransactionIdRelationshipsTagsRequestWithBody(server, transactionId, "application/json", bodyReader)
}

// NewDeleteTransactionsTransactionIdRelationshipsTagsRequestWithBody generates requests for DeleteTransactionsTransactionIdRelationshipsTags with any type of body
func NewDeleteTransactionsTransactionIdRelationshipsTagsRequestWithBody(server string, transactionId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "transactionId", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transactions/%s/relationships/tags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewPostTransactionsTransactionIdRelationshipsTagsRequest calls the generic PostTransactionsTransactionIdRelationshipsTags builder with application/json body
func NewPostTransactionsTransactionIdRelationshipsTagsRequest(server string, transactionId string, body PostTransactionsTransactionIdRelationshipsTagsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostTransactionsTransactionIdRelationshipsTagsRequestWithBody(server, transactionId, "application/json", bodyReader)
}

// NewPostTransactionsTransactionIdRelationshipsTagsRequestWithBody generates requests for PostTransactionsTransactionIdRelationshipsTags with any type of body
func NewPostTransactionsTransactionIdRelationshipsTagsRequestWithBody(server string, transactionId string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "transactionId", runtime.ParamLocationPath, transactionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/transactions/%s/relationships/tags", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetUtilPingRequest generates requests for GetUtilPing
func NewGetUtilPingRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/util/ping")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWebhooksRequest generates requests for GetWebhooks
func NewGetWebhooksRequest(server string, params *GetWebhooksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page[size]", runtime.ParamLocationQuery, params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostWebhooksRequest calls the generic PostWebhooks builder with application/json body
func NewPostWebhooksRequest(server string, body PostWebhooksJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostWebhooksRequestWithBody(server, "application/json", bodyReader)
}

// NewPostWebhooksRequestWithBody generates requests for PostWebhooks with any type of body
func NewPostWebhooksRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteWebhooksIdRequest generates requests for DeleteWebhooksId
func NewDeleteWebhooksIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWebhooksIdRequest generates requests for GetWebhooksId
func NewGetWebhooksIdRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWebhooksWebhookIdLogsRequest generates requests for GetWebhooksWebhookIdLogs
func NewGetWebhooksWebhookIdLogsRequest(server string, webhookId string, params *GetWebhooksWebhookIdLogsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "webhookId", runtime.ParamLocationPath, webhookId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks/%s/logs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page[size]", runtime.ParamLocationQuery, params.PageSize); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostWebhooksWebhookIdPingRequest generates requests for PostWebhooksWebhookIdPing
func NewPostWebhooksWebhookIdPingRequest(server string, webhookId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "webhookId", runtime.ParamLocationPath, webhookId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks/%s/ping", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAccountsWithResponse request
	GetAccountsWithResponse(ctx context.Context, params *GetAccountsParams, reqEditors ...RequestEditorFn) (*GetAccountsResponse, error)

	// GetAccountsAccountIdTransactionsWithResponse request
	GetAccountsAccountIdTransactionsWithResponse(ctx context.Context, accountId string, params *GetAccountsAccountIdTransactionsParams, reqEditors ...RequestEditorFn) (*GetAccountsAccountIdTransactionsResponse, error)

	// GetAccountsIdWithResponse request
	GetAccountsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAccountsIdResponse, error)

	// GetAttachmentsWithResponse request
	GetAttachmentsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAttachmentsResponse, error)

	// GetAttachmentsIdWithResponse request
	GetAttachmentsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAttachmentsIdResponse, error)

	// GetCategoriesWithResponse request
	GetCategoriesWithResponse(ctx context.Context, params *GetCategoriesParams, reqEditors ...RequestEditorFn) (*GetCategoriesResponse, error)

	// GetCategoriesIdWithResponse request
	GetCategoriesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetCategoriesIdResponse, error)

	// GetTagsWithResponse request
	GetTagsWithResponse(ctx context.Context, params *GetTagsParams, reqEditors ...RequestEditorFn) (*GetTagsResponse, error)

	// GetTransactionsWithResponse request
	GetTransactionsWithResponse(ctx context.Context, params *GetTransactionsParams, reqEditors ...RequestEditorFn) (*GetTransactionsResponse, error)

	// GetTransactionsIdWithResponse request
	GetTransactionsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetTransactionsIdResponse, error)

	// PatchTransactionsTransactionIdRelationshipsCategoryWithBodyWithResponse request with any body
	PatchTransactionsTransactionIdRelationshipsCategoryWithBodyWithResponse(ctx context.Context, transactionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchTransactionsTransactionIdRelationshipsCategoryResponse, error)

	PatchTransactionsTransactionIdRelationshipsCategoryWithResponse(ctx context.Context, transactionId string, body PatchTransactionsTransactionIdRelationshipsCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchTransactionsTransactionIdRelationshipsCategoryResponse, error)

	// DeleteTransactionsTransactionIdRelationshipsTagsWithBodyWithResponse request with any body
	DeleteTransactionsTransactionIdRelationshipsTagsWithBodyWithResponse(ctx context.Context, transactionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteTransactionsTransactionIdRelationshipsTagsResponse, error)

	DeleteTransactionsTransactionIdRelationshipsTagsWithResponse(ctx context.Context, transactionId string, body DeleteTransactionsTransactionIdRelationshipsTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteTransactionsTransactionIdRelationshipsTagsResponse, error)

	// PostTransactionsTransactionIdRelationshipsTagsWithBodyWithResponse request with any body
	PostTransactionsTransactionIdRelationshipsTagsWithBodyWithResponse(ctx context.Context, transactionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTransactionsTransactionIdRelationshipsTagsResponse, error)

	PostTransactionsTransactionIdRelationshipsTagsWithResponse(ctx context.Context, transactionId string, body PostTransactionsTransactionIdRelationshipsTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTransactionsTransactionIdRelationshipsTagsResponse, error)

	// GetUtilPingWithResponse request
	GetUtilPingWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUtilPingResponse, error)

	// GetWebhooksWithResponse request
	GetWebhooksWithResponse(ctx context.Context, params *GetWebhooksParams, reqEditors ...RequestEditorFn) (*GetWebhooksResponse, error)

	// PostWebhooksWithBodyWithResponse request with any body
	PostWebhooksWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostWebhooksResponse, error)

	PostWebhooksWithResponse(ctx context.Context, body PostWebhooksJSONRequestBody, reqEditors ...RequestEditorFn) (*PostWebhooksResponse, error)

	// DeleteWebhooksIdWithResponse request
	DeleteWebhooksIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteWebhooksIdResponse, error)

	// GetWebhooksIdWithResponse request
	GetWebhooksIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetWebhooksIdResponse, error)

	// GetWebhooksWebhookIdLogsWithResponse request
	GetWebhooksWebhookIdLogsWithResponse(ctx context.Context, webhookId string, params *GetWebhooksWebhookIdLogsParams, reqEditors ...RequestEditorFn) (*GetWebhooksWebhookIdLogsResponse, error)

	// PostWebhooksWebhookIdPingWithResponse request
	PostWebhooksWebhookIdPingWithResponse(ctx context.Context, webhookId string, reqEditors ...RequestEditorFn) (*PostWebhooksWebhookIdPingResponse, error)
}

type GetAccountsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListAccountsResponse
}

// Status returns HTTPResponse.Status
func (r GetAccountsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccountsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAccountsAccountIdTransactionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListTransactionsResponse
}

// Status returns HTTPResponse.Status
func (r GetAccountsAccountIdTransactionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccountsAccountIdTransactionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAccountsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetAccountResponse
}

// Status returns HTTPResponse.Status
func (r GetAccountsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAccountsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAttachmentsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListAttachmentsResponse
}

// Status returns HTTPResponse.Status
func (r GetAttachmentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAttachmentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAttachmentsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetAttachmentResponse
}

// Status returns HTTPResponse.Status
func (r GetAttachmentsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAttachmentsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCategoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListCategoriesResponse
}

// Status returns HTTPResponse.Status
func (r GetCategoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCategoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCategoriesIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetCategoryResponse
}

// Status returns HTTPResponse.Status
func (r GetCategoriesIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCategoriesIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListTagsResponse
}

// Status returns HTTPResponse.Status
func (r GetTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTransactionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListTransactionsResponse
}

// Status returns HTTPResponse.Status
func (r GetTransactionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTransactionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTransactionsIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetTransactionResponse
}

// Status returns HTTPResponse.Status
func (r GetTransactionsIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTransactionsIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchTransactionsTransactionIdRelationshipsCategoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PatchTransactionsTransactionIdRelationshipsCategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchTransactionsTransactionIdRelationshipsCategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTransactionsTransactionIdRelationshipsTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteTransactionsTransactionIdRelationshipsTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTransactionsTransactionIdRelationshipsTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostTransactionsTransactionIdRelationshipsTagsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostTransactionsTransactionIdRelationshipsTagsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostTransactionsTransactionIdRelationshipsTagsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUtilPingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PingResponse
	JSON401      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetUtilPingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUtilPingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWebhooksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListWebhooksResponse
}

// Status returns HTTPResponse.Status
func (r GetWebhooksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWebhooksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostWebhooksResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CreateWebhookResponse
}

// Status returns HTTPResponse.Status
func (r PostWebhooksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostWebhooksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWebhooksIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteWebhooksIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWebhooksIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWebhooksIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetWebhookResponse
}

// Status returns HTTPResponse.Status
func (r GetWebhooksIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWebhooksIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWebhooksWebhookIdLogsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ListWebhookDeliveryLogsResponse
}

// Status returns HTTPResponse.Status
func (r GetWebhooksWebhookIdLogsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWebhooksWebhookIdLogsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostWebhooksWebhookIdPingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *WebhookEventCallback
}

// Status returns HTTPResponse.Status
func (r PostWebhooksWebhookIdPingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostWebhooksWebhookIdPingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAccountsWithResponse request returning *GetAccountsResponse
func (c *ClientWithResponses) GetAccountsWithResponse(ctx context.Context, params *GetAccountsParams, reqEditors ...RequestEditorFn) (*GetAccountsResponse, error) {
	rsp, err := c.GetAccounts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccountsResponse(rsp)
}

// GetAccountsAccountIdTransactionsWithResponse request returning *GetAccountsAccountIdTransactionsResponse
func (c *ClientWithResponses) GetAccountsAccountIdTransactionsWithResponse(ctx context.Context, accountId string, params *GetAccountsAccountIdTransactionsParams, reqEditors ...RequestEditorFn) (*GetAccountsAccountIdTransactionsResponse, error) {
	rsp, err := c.GetAccountsAccountIdTransactions(ctx, accountId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccountsAccountIdTransactionsResponse(rsp)
}

// GetAccountsIdWithResponse request returning *GetAccountsIdResponse
func (c *ClientWithResponses) GetAccountsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAccountsIdResponse, error) {
	rsp, err := c.GetAccountsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAccountsIdResponse(rsp)
}

// GetAttachmentsWithResponse request returning *GetAttachmentsResponse
func (c *ClientWithResponses) GetAttachmentsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAttachmentsResponse, error) {
	rsp, err := c.GetAttachments(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAttachmentsResponse(rsp)
}

// GetAttachmentsIdWithResponse request returning *GetAttachmentsIdResponse
func (c *ClientWithResponses) GetAttachmentsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetAttachmentsIdResponse, error) {
	rsp, err := c.GetAttachmentsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAttachmentsIdResponse(rsp)
}

// GetCategoriesWithResponse request returning *GetCategoriesResponse
func (c *ClientWithResponses) GetCategoriesWithResponse(ctx context.Context, params *GetCategoriesParams, reqEditors ...RequestEditorFn) (*GetCategoriesResponse, error) {
	rsp, err := c.GetCategories(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCategoriesResponse(rsp)
}

// GetCategoriesIdWithResponse request returning *GetCategoriesIdResponse
func (c *ClientWithResponses) GetCategoriesIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetCategoriesIdResponse, error) {
	rsp, err := c.GetCategoriesId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCategoriesIdResponse(rsp)
}

// GetTagsWithResponse request returning *GetTagsResponse
func (c *ClientWithResponses) GetTagsWithResponse(ctx context.Context, params *GetTagsParams, reqEditors ...RequestEditorFn) (*GetTagsResponse, error) {
	rsp, err := c.GetTags(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTagsResponse(rsp)
}

// GetTransactionsWithResponse request returning *GetTransactionsResponse
func (c *ClientWithResponses) GetTransactionsWithResponse(ctx context.Context, params *GetTransactionsParams, reqEditors ...RequestEditorFn) (*GetTransactionsResponse, error) {
	rsp, err := c.GetTransactions(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTransactionsResponse(rsp)
}

// GetTransactionsIdWithResponse request returning *GetTransactionsIdResponse
func (c *ClientWithResponses) GetTransactionsIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetTransactionsIdResponse, error) {
	rsp, err := c.GetTransactionsId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTransactionsIdResponse(rsp)
}

// PatchTransactionsTransactionIdRelationshipsCategoryWithBodyWithResponse request with arbitrary body returning *PatchTransactionsTransactionIdRelationshipsCategoryResponse
func (c *ClientWithResponses) PatchTransactionsTransactionIdRelationshipsCategoryWithBodyWithResponse(ctx context.Context, transactionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchTransactionsTransactionIdRelationshipsCategoryResponse, error) {
	rsp, err := c.PatchTransactionsTransactionIdRelationshipsCategoryWithBody(ctx, transactionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchTransactionsTransactionIdRelationshipsCategoryResponse(rsp)
}

func (c *ClientWithResponses) PatchTransactionsTransactionIdRelationshipsCategoryWithResponse(ctx context.Context, transactionId string, body PatchTransactionsTransactionIdRelationshipsCategoryJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchTransactionsTransactionIdRelationshipsCategoryResponse, error) {
	rsp, err := c.PatchTransactionsTransactionIdRelationshipsCategory(ctx, transactionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchTransactionsTransactionIdRelationshipsCategoryResponse(rsp)
}

// DeleteTransactionsTransactionIdRelationshipsTagsWithBodyWithResponse request with arbitrary body returning *DeleteTransactionsTransactionIdRelationshipsTagsResponse
func (c *ClientWithResponses) DeleteTransactionsTransactionIdRelationshipsTagsWithBodyWithResponse(ctx context.Context, transactionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteTransactionsTransactionIdRelationshipsTagsResponse, error) {
	rsp, err := c.DeleteTransactionsTransactionIdRelationshipsTagsWithBody(ctx, transactionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTransactionsTransactionIdRelationshipsTagsResponse(rsp)
}

func (c *ClientWithResponses) DeleteTransactionsTransactionIdRelationshipsTagsWithResponse(ctx context.Context, transactionId string, body DeleteTransactionsTransactionIdRelationshipsTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteTransactionsTransactionIdRelationshipsTagsResponse, error) {
	rsp, err := c.DeleteTransactionsTransactionIdRelationshipsTags(ctx, transactionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTransactionsTransactionIdRelationshipsTagsResponse(rsp)
}

// PostTransactionsTransactionIdRelationshipsTagsWithBodyWithResponse request with arbitrary body returning *PostTransactionsTransactionIdRelationshipsTagsResponse
func (c *ClientWithResponses) PostTransactionsTransactionIdRelationshipsTagsWithBodyWithResponse(ctx context.Context, transactionId string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTransactionsTransactionIdRelationshipsTagsResponse, error) {
	rsp, err := c.PostTransactionsTransactionIdRelationshipsTagsWithBody(ctx, transactionId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTransactionsTransactionIdRelationshipsTagsResponse(rsp)
}

func (c *ClientWithResponses) PostTransactionsTransactionIdRelationshipsTagsWithResponse(ctx context.Context, transactionId string, body PostTransactionsTransactionIdRelationshipsTagsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostTransactionsTransactionIdRelationshipsTagsResponse, error) {
	rsp, err := c.PostTransactionsTransactionIdRelationshipsTags(ctx, transactionId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTransactionsTransactionIdRelationshipsTagsResponse(rsp)
}

// GetUtilPingWithResponse request returning *GetUtilPingResponse
func (c *ClientWithResponses) GetUtilPingWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUtilPingResponse, error) {
	rsp, err := c.GetUtilPing(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUtilPingResponse(rsp)
}

// GetWebhooksWithResponse request returning *GetWebhooksResponse
func (c *ClientWithResponses) GetWebhooksWithResponse(ctx context.Context, params *GetWebhooksParams, reqEditors ...RequestEditorFn) (*GetWebhooksResponse, error) {
	rsp, err := c.GetWebhooks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWebhooksResponse(rsp)
}

// PostWebhooksWithBodyWithResponse request with arbitrary body returning *PostWebhooksResponse
func (c *ClientWithResponses) PostWebhooksWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostWebhooksResponse, error) {
	rsp, err := c.PostWebhooksWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostWebhooksResponse(rsp)
}

func (c *ClientWithResponses) PostWebhooksWithResponse(ctx context.Context, body PostWebhooksJSONRequestBody, reqEditors ...RequestEditorFn) (*PostWebhooksResponse, error) {
	rsp, err := c.PostWebhooks(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostWebhooksResponse(rsp)
}

// DeleteWebhooksIdWithResponse request returning *DeleteWebhooksIdResponse
func (c *ClientWithResponses) DeleteWebhooksIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteWebhooksIdResponse, error) {
	rsp, err := c.DeleteWebhooksId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWebhooksIdResponse(rsp)
}

// GetWebhooksIdWithResponse request returning *GetWebhooksIdResponse
func (c *ClientWithResponses) GetWebhooksIdWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetWebhooksIdResponse, error) {
	rsp, err := c.GetWebhooksId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWebhooksIdResponse(rsp)
}

// GetWebhooksWebhookIdLogsWithResponse request returning *GetWebhooksWebhookIdLogsResponse
func (c *ClientWithResponses) GetWebhooksWebhookIdLogsWithResponse(ctx context.Context, webhookId string, params *GetWebhooksWebhookIdLogsParams, reqEditors ...RequestEditorFn) (*GetWebhooksWebhookIdLogsResponse, error) {
	rsp, err := c.GetWebhooksWebhookIdLogs(ctx, webhookId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWebhooksWebhookIdLogsResponse(rsp)
}

// PostWebhooksWebhookIdPingWithResponse request returning *PostWebhooksWebhookIdPingResponse
func (c *ClientWithResponses) PostWebhooksWebhookIdPingWithResponse(ctx context.Context, webhookId string, reqEditors ...RequestEditorFn) (*PostWebhooksWebhookIdPingResponse, error) {
	rsp, err := c.PostWebhooksWebhookIdPing(ctx, webhookId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostWebhooksWebhookIdPingResponse(rsp)
}

// ParseGetAccountsResponse parses an HTTP response from a GetAccountsWithResponse call
func ParseGetAccountsResponse(rsp *http.Response) (*GetAccountsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccountsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListAccountsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAccountsAccountIdTransactionsResponse parses an HTTP response from a GetAccountsAccountIdTransactionsWithResponse call
func ParseGetAccountsAccountIdTransactionsResponse(rsp *http.Response) (*GetAccountsAccountIdTransactionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccountsAccountIdTransactionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListTransactionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAccountsIdResponse parses an HTTP response from a GetAccountsIdWithResponse call
func ParseGetAccountsIdResponse(rsp *http.Response) (*GetAccountsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAccountsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetAccountResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAttachmentsResponse parses an HTTP response from a GetAttachmentsWithResponse call
func ParseGetAttachmentsResponse(rsp *http.Response) (*GetAttachmentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAttachmentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListAttachmentsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAttachmentsIdResponse parses an HTTP response from a GetAttachmentsIdWithResponse call
func ParseGetAttachmentsIdResponse(rsp *http.Response) (*GetAttachmentsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAttachmentsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetAttachmentResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCategoriesResponse parses an HTTP response from a GetCategoriesWithResponse call
func ParseGetCategoriesResponse(rsp *http.Response) (*GetCategoriesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCategoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListCategoriesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetCategoriesIdResponse parses an HTTP response from a GetCategoriesIdWithResponse call
func ParseGetCategoriesIdResponse(rsp *http.Response) (*GetCategoriesIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCategoriesIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetCategoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTagsResponse parses an HTTP response from a GetTagsWithResponse call
func ParseGetTagsResponse(rsp *http.Response) (*GetTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListTagsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTransactionsResponse parses an HTTP response from a GetTransactionsWithResponse call
func ParseGetTransactionsResponse(rsp *http.Response) (*GetTransactionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTransactionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListTransactionsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetTransactionsIdResponse parses an HTTP response from a GetTransactionsIdWithResponse call
func ParseGetTransactionsIdResponse(rsp *http.Response) (*GetTransactionsIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTransactionsIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetTransactionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePatchTransactionsTransactionIdRelationshipsCategoryResponse parses an HTTP response from a PatchTransactionsTransactionIdRelationshipsCategoryWithResponse call
func ParsePatchTransactionsTransactionIdRelationshipsCategoryResponse(rsp *http.Response) (*PatchTransactionsTransactionIdRelationshipsCategoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchTransactionsTransactionIdRelationshipsCategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteTransactionsTransactionIdRelationshipsTagsResponse parses an HTTP response from a DeleteTransactionsTransactionIdRelationshipsTagsWithResponse call
func ParseDeleteTransactionsTransactionIdRelationshipsTagsResponse(rsp *http.Response) (*DeleteTransactionsTransactionIdRelationshipsTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTransactionsTransactionIdRelationshipsTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParsePostTransactionsTransactionIdRelationshipsTagsResponse parses an HTTP response from a PostTransactionsTransactionIdRelationshipsTagsWithResponse call
func ParsePostTransactionsTransactionIdRelationshipsTagsResponse(rsp *http.Response) (*PostTransactionsTransactionIdRelationshipsTagsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostTransactionsTransactionIdRelationshipsTagsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetUtilPingResponse parses an HTTP response from a GetUtilPingWithResponse call
func ParseGetUtilPingResponse(rsp *http.Response) (*GetUtilPingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUtilPingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PingResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetWebhooksResponse parses an HTTP response from a GetWebhooksWithResponse call
func ParseGetWebhooksResponse(rsp *http.Response) (*GetWebhooksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWebhooksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListWebhooksResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostWebhooksResponse parses an HTTP response from a PostWebhooksWithResponse call
func ParsePostWebhooksResponse(rsp *http.Response) (*PostWebhooksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostWebhooksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CreateWebhookResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteWebhooksIdResponse parses an HTTP response from a DeleteWebhooksIdWithResponse call
func ParseDeleteWebhooksIdResponse(rsp *http.Response) (*DeleteWebhooksIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWebhooksIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetWebhooksIdResponse parses an HTTP response from a GetWebhooksIdWithResponse call
func ParseGetWebhooksIdResponse(rsp *http.Response) (*GetWebhooksIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWebhooksIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetWebhookResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetWebhooksWebhookIdLogsResponse parses an HTTP response from a GetWebhooksWebhookIdLogsWithResponse call
func ParseGetWebhooksWebhookIdLogsResponse(rsp *http.Response) (*GetWebhooksWebhookIdLogsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWebhooksWebhookIdLogsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ListWebhookDeliveryLogsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostWebhooksWebhookIdPingResponse parses an HTTP response from a PostWebhooksWebhookIdPingWithResponse call
func ParsePostWebhooksWebhookIdPingResponse(rsp *http.Response) (*PostWebhooksWebhookIdPingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostWebhooksWebhookIdPingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest WebhookEventCallback
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}
